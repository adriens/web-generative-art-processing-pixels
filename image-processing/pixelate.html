<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Image processing | OPT</title>
    <link rel="stylesheet" type="text/css" href="css/master.css">
    <script src="js/p5.min.js"></script>
</head>
<body>
    <script>
        let image;
        let images = [];

        let slider;
        let color_mode;
        let dir_mode;

        let COLS,ROWS;
        let cell_width, cell_height;

        function preload(){
            images.push(loadImage("img/frog.jpg"));
            images.push(loadImage("img/rastadidi.png"));
            images.push(createCapture(VIDEO));
            images[2].hide();
        }

        function setup(){
            pixelDensity(1);
            createCanvas(400, 400); // Setting the canvas to be the image's size

            // Slider to change cells size
            slider = createSlider(1, 200, 50, 1);
            slider.style('width', '150px');

            inputPic = createSelect("input");
            inputPic.option("Frog");
            inputPic.option("Rastadidi");
            inputPic.option("Webcam");
            inputPic.selected("Frog");

            dir_mode = createSelect("dir");
            dir_mode.option("Grid");
            dir_mode.option("Columns");
            dir_mode.option("Rows");
            dir_mode.selected("Grid");

            color_mode = createSelect("color");
            color_mode.option("Minimum");
            color_mode.option("Maximum");
            color_mode.option("Average");
            color_mode.option("Median");
            color_mode.option("Black & White");
            color_mode.option("Negative");
            color_mode.selected("Average");
        }

        /**
         * This code makes the image looks pixelated by calculating the average color for each cells of the picture.
         * Cells size are modifiable using the slider at the bottom of the canvas
         */
        function draw(){
            background(0);
            if(inputPic.value() === "Frog"){
                image = images[0];
            } else if(inputPic.value() === "Rastadidi"){
                image = images[1];
            } else {
                image = images[2];
            }
            resizeCanvas(image.width, image.height);
            slider.position(width/2-75, height-20);

            image.loadPixels();

            COLS = ROWS = slider.value();
            cell_width = Math.round(width/COLS);
            cell_height = Math.round(height/ROWS);

            if(dir_mode.value() === "Grid") {
                gridShow();
            } else if(dir_mode.value() === "Columns") {
                columnShow();
            } else if(dir_mode.value() === "Rows"){
                rowShow();
            }
            var nbPixels = Math.round(image.height/cell_height) * Math.round(image.width/cell_width);
            updateNbPixels(nbPixels);
        }

        function gridShow(){
            let colors = [];
            /* Looping through the image from cells to cells */
            for(var x = 0; x < width; x=x+cell_width){
                for(var y = 0; y < height; y=y+cell_height){
                    /* Looping through each pixels of said cell */
                    for(var n = x; n < x + cell_width; n++){
                        colors[n] = [];
                        for(var m = y; m < y + cell_height; m++) {
                            let index = (n + m * width)*4;

                            let r = image.pixels[index];
                            let g = image.pixels[index+1];
                            let b = image.pixels[index+2];
                            let a = image.pixels[index+3];

                            colors[n].push([r, g, b, a]); // We gather the RGB color of each pixels in the array "colors"
                        }
                    }

                    let newColours = coloursComputation(colors);

                    fill(newColours[0], newColours[1], newColours[2], newColours[3]);
                    rect(x, y, cell_width, cell_height);
                }
            }
        }

        function columnShow() {
            let colors = [];
            /* Looping through the image from cells to cells */
            for (var x = 0; x < width; x = x + cell_width) {
                /* Looping through each pixels of said cell */
                for (var n = x; n < x + cell_width; n++) {
                    colors[n] = [];
                    for (var m = 0; m < height; m++) {
                        let index = (n + m * width) * 4;

                        let r = image.pixels[index];
                        let g = image.pixels[index + 1];
                        let b = image.pixels[index + 2];
                        let a = image.pixels[index + 3];

                        colors[n].push([r, g, b, a]); // We gather the RGB color of each pixels in the array "colors"
                    }
                }

                let newColours = coloursComputation(colors);

                fill(newColours[0], newColours[1], newColours[2], newColours[3]);
                rect(x, 0, cell_width, height);
            }
        }

        function rowShow(){
            let colors = [];
            /* Looping through the image from cells to cells */
            for (var x = 0; x < height; x = x + cell_height) {
                /* Looping through each pixels of said cell */
                for (var n = 0; n < width; n++) {
                    colors[n] = [];
                    for (var m = x; m < x + cell_height; m++) {
                        let index = (n + m * width)*4;

                        let r = image.pixels[index];
                        let g = image.pixels[index+1];
                        let b = image.pixels[index+2];
                        let a = image.pixels[index+3];

                        colors[n].push([r,g,b,a]);
                    }
                }

                let newColours = coloursComputation(colors);

                fill(newColours[0], newColours[1], newColours[2], newColours[3]);
                rect(0, x, width, cell_height);
            }
        }

        function coloursComputation(colors){
            let j;
            let i;
            // RGBA average vars
            let newR = 0;
            let newG = 0;
            let newB = 0;
            let newA = 0;

            if(color_mode.value() === "Minimum" || color_mode.value() === "Maximum" || color_mode.value() === "Median") {
                let reds = [];
                let greens = [];
                let blues = [];
                let alphas = [];

                for (i = 0; i < colors.length; i++) {
                    for (j = 0; j < colors[i].length; j++) {
                        reds.push(colors[i][j][0]);
                        greens.push(colors[i][j][1]);
                        blues.push(colors[i][j][2]);
                        alphas.push(colors[i][j][3]);
                    }
                    colors[i] = []
                }

                if (color_mode.value() === "Minimum") {
                    newR = Math.min(...reds);
                    newG = Math.min(...greens);
                    newB = Math.min(...blues);
                    newA = Math.min(...alphas);
                } else if (color_mode.value() === "Maximum") {
                    newR = Math.max(...reds);
                    newG = Math.max(...greens);
                    newB = Math.max(...blues);
                    newA = Math.max(...alphas);
                } else if (color_mode.value() === "Median") {
                    newR = median(reds);
                    newG = median(greens);
                    newB = median(blues);
                    newA = median(alphas);
                }
            } else {
                let size = 0;
                for (i = 0; i < colors.length; i++) {
                    for (j = 0; j < colors[i].length; j++) {
                        newR += colors[i][j][0];
                        newG += colors[i][j][1];
                        newB += colors[i][j][2];
                        newA += colors[i][j][3];
                        size++;
                    }
                    colors[i] = [];
                }
                newR = newR/size;
                newG = newG/size;
                newB = newB/size;
                newA = newA/size;
            }

            noStroke();
            if(color_mode.value() === "Black & White") {
                newR = newG = newB = (newR + newG + newB)/3;
            } else if(color_mode.value() === "Negative"){
                newR = 255-newR;
                newG = 255-newG;
                newB = 255-newB;
            }

            return [newR, newG, newB, newA];
        }

        function updateNbPixels(nbPixels){
            push();
            stroke(0)
            fill(255);
            text(nbPixels+" px", width-70, 20);
            pop();
        }

        function median(values){
            if(values.length ===0) return 0;

            values.sort(function(a,b){
                return a-b;
            });

            var half = Math.floor(values.length / 2);

            if (values.length % 2) return values[half];

            return (values[half - 1] + values[half]) / 2.0;
        }
    </script>
</body>
</html>